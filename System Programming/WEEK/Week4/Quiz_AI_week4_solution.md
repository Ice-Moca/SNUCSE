# 2025 Spring SNU System Programming - Weekly Quiz (Week 4, with Solutions)

We have prepared some light quizzes related to class content of week 4.  
These problems have been selected from those generated by **AI tool (Cramify)**,  
based on your class ppt content.

There is no need to submit anything after reviewing this material,  
but we hope it will help you review the class content you learned this week and prepare for the quiz.

---

Weekly Quiz has two documents, one with only the problems and  
the other with both the problems and solutions.  

# Question 1

| Data Type | Size (bytes) | Alignment (bytes) |
|-------|-------|-------|
| char	| 1 | 1 |
| short	| 2 | 2 |
| int	| 4 | 4 |
| long	| 8 | 8 |
| long double	| 16 | 16 |
| pointer	| 8 | 8 |

Consider a 64-bit x86-64 Linux system with the size and alignment requirements for various data types as shown in the table above.  
You are designing a struct named Data with the following members: `char c; long l; int i; char d;`.  
Calculate the total size of the struct Data considering data alignment.  
Then, explain how padding is used to achieve this alignment and why it's beneficial for performance.

**Answer:**  
The size of the struct Data is 24 bytes.  
Padding is used to align members to their required boundaries.  
7 bytes of padding are inserted after the first char and another 3 bytes at the end of the struct.  
This ensures efficient memory access by the processor, preventing performance penalties associated with misaligned accesses.

**Solution:**  
1. Analyze individual member sizes and alignments:
- `char c`: 1 byte
- `long l`: 8 bytes, aligned to 8 bytes
- `int i` : 4 bytes, aligned to 4 bytes
- `char d`: 1 byte
2. Layout the struct members with alignment:
- `char c`: placed at offset 0 (1 byte).
- `long l`: must start at an address divisible by 8. Since the current offset is 1, 7 bytes of padding are added. long l is placed at offset 8 (8 bytes).
- `int i`: must start at an address divisible by 4. The current offset is 16, which is divisible by 4. int i is placed at offset 16 (4 bytes).
- `char d`: placed at offset 20 (1 byte).
3. Calculate total size and padding:  
The current offset is 21.  
To ensure that an array of Data structs maintains proper alignment for all members, the total size of the struct must be a multiple of the largest alignment requirement, which is 8.  
Therefore, 3 bytes of padding are added at the end, making the total size 24 bytes, which is a multiple of 8.
4. Benefits of padding:  
Padding ensures that every member of the struct is aligned correctly.  
This is crucial for performance because misaligned memory accesses can lead to significant performance penalties.  
Modern processors are optimized to access aligned data efficiently.  
Accessing misaligned data might require multiple memory accesses, increasing the overall execution time.

# Question 2

Consider the following C code snippet:

```c
void modifyValue(int a, int *b) {
    a = 10;
    *b = 20;
}

int main() {
    int x = 5;
    int y = 5;
    modifyValue(x, &y);
    // What are the values of x and y after the function call?
}
```
Explain the final values of x and y after the call to modifyValue, highlighting the difference between how the two parameters are handled.

**Answer:**  
x = 5, y = 20

**Solution:**  
In the modifyValue function, a is passed by value, while b is passed by reference.
1. Pass-by-value (a):  
A copy of the value of x (which is 5) is passed to the function.  
Inside the function, the value of this copy (a) is changed to 10.  
This change does not affect the original variable x in the main function.
2. Pass-by-reference (b):  
The memory address of y is passed to the function.  
Inside the function, *b dereferences this address, meaning it accesses and modifies the original variable y directly.  
Therefore, the value of y in the main function is changed to 20.

Therefore, after the function call, x remains 5, and y becomes 20.

# Question 3

In C, if `p` is declared as `int *p;` and subsequently assigned the return value of `malloc(sizeof(int) * 5);`, which statement best describes the relationship between `p` and the allocated memory?

A) `p` becomes an array of 5 integers, directly storing the allocated values within itself.  
B) `p` holds the starting address of a dynamically allocated block of memory on the heap, sufficient to store 5 integers.  
C) `p` stores the size (in bytes) of the allocated memory block, and the actual data is stored elsewhere.  
D) `p` stores the first integer of the allocated array, and the subsequent integers are stored in contiguous memory locations after `p`.  

**Answer: B**

**Solution:**  
The `malloc` function allocates a block of memory of the specified size (in this case, enough for 5 integers) and returns a pointer to the beginning of that block.  
The pointer `p` now stores the starting address of this dynamically allocated memory.  
`p` itself is a variable stored elsewhere (likely on the stack), but its value is the address of the memory block on the heap.

# Question 4

| Member | Description |
|-------|-------|
| `st_dev`	| Device ID |
| `st_ino`	| Inode number |
| `st_mode`	| File type and mode |
| `st_nlink`	| Number of hard links |
| `st_uid`	| User ID of owner |
| `st_gid`	| Group ID of owner |
| `st_rdev`	| Device ID (if special file) |
| `st_size`	| Total size, in bytes |
| `st_blksize`	| Block size for file system I/O |
| `st_blocks`	| Number of 512B blocks allocated |
| `st_atim`	| Time of last access |
| `st_mtim`	| Time of last modification |
| `st_ctim`	| Time of last status change |

Consider the struct stat structure used to retrieve file metadata.  
Using the table above, identify which member of the struct stat structure would store the following information:

1. The size of the file in bytes.
2. The last time the file's contents were modified.
3. The user ID of the file's owner.
4. The number of hard links to the file.
5. The file type and permissions.

**Answer:**  
1. `st_size`
2. `st_mtim`
3. `st_uid`
4. `st_nlink`
5. `st_mode`

**Solution:**  
1. The size of the file in bytes is stored in `st_size`.
2. The last time the file's contents were modified is stored in `st_mtim`.
3. The user ID of the file's owner is stored in `st_uid`.
4. The number of hard links to the file is stored in `st_nlink`.
5. The file type and permissions are stored in `st_mode`.

# Question 5

Process A opens a file, "data.txt", twice using the `open()` system call.  
Explain how this scenario is represented within the kernel's file management structures, specifically referencing descriptor tables, the open file table, and the v-node table.  
How does this representation enable file sharing?

**Answer:**  
Two file descriptors in Process A's descriptor table point to two separate entries in the open file table.  
Both open file table entries, however, point to the same v-node table entry representing "data.txt".  
This allows independent file offsets for each descriptor while sharing access to the same underlying file.

**Solution:**  
When Process A opens "data.txt" the first time, the kernel creates an entry in the v-node table for the file if one doesn't already exist.  
This v-node stores file metadata like file type, size, and access permissions.  
An entry is also created in the open file table. This entry includes information such as the current file offset and access mode.  
Finally, an entry is added to Process A's descriptor table, with the file descriptor pointing to the entry in the open file table.  

When Process A opens "data.txt" a second time, the kernel does not create a new v-node.  
The existing v-node is reused, as it represents the same file on disk.  
However, a new entry is created in the open file table. This new entry will have its own independent file offset.  
A new file descriptor in Process A's descriptor table is then created, pointing to this second entry in the open file table.  
This mechanism allows multiple file descriptors within the same process (or even across different processes) to share access to the same underlying file via the single v-node, while maintaining independent file offsets through separate open file table entries.

# Question 6

Process A opens "data.txt" twice using the `open()` system call, obtaining file descriptors 3 and 4.  
Process B then opens the same file, receiving file descriptor 5.  
Explain how the Unix kernel manages this scenario using the descriptor table, open file table, and v-node table.  
Specifically, describe the relationships between these structures and how they facilitate file sharing, including the role of reference counting.

**Answer:**  
Each process has its own descriptor table entries pointing to separate open file table entries.  
All open file table entries point to a single v-node table entry for the shared file.  
The v-node table entry maintains a reference count, incremented with each open and decremented with each close, ensuring consistent access to the file's metadata.

**Solution:**  
1. Descriptor Tables:  
Each process (A and B) has its own descriptor table.  
In Process A, entries 3 and 4 both point to separate entries in the open file table.  
In Process B, entry 5 points to yet another entry in the open file table.
2. Open File Table:  
The open file table is system-wide.  
Three entries are created, one for each call to `open()`.  
Each entry stores information like the current file offset (which can be different for each descriptor) and a pointer to the corresponding v-node table entry.
3. V-node Table:  
The v-node table is also system-wide.  
A single entry exists for "data.txt" in the v-node table.  
This entry holds the file's metadata (e.g., file size, permissions, location on disk).  
Crucially, it also maintains a reference count. In this scenario, the reference count for "data.txt" in the v-node table would be 3, reflecting the three open file table entries referencing it.
4. File Sharing Mechanism:  
When Process A opens "data.txt" the first time, a v-node table entry is created if it doesn't already exist, and its reference count is initialized to 1.  
The second `open()` by Process A increments the reference count to 2.  
When Process B opens the file, the existing v-node table entry is used, and the reference count becomes 3.  
This shared v-node table entry ensures that all processes access the same underlying file data and metadata.  
The separate open file table entries allow each process to maintain its own independent file offset.

# Question 7

Explain the system calls involved in redirecting standard output of a command, such as `ls`, to a file named `output.txt` in a Unix shell.  
Specifically, detail how the shell manipulates file descriptors to achieve this redirection.

**Answer:**  
The shell uses `open()` to open the destination file, obtaining a new file descriptor.  
Then, `dup2()` redirects standard output (STDOUT_FILENO) to the new file descriptor.  
Subsequently, the executed command's output is written to the file.

**Solution:**  
1. The shell first opens the file `output.txt` for writing using the `open()` system call.  
If the file doesn't exist, it's created. If it exists, it might be truncated depending on flags.  
This call returns a new file descriptor, let's say fd.
2. The shell then uses the `dup2()` system call: `dup2(fd, STDOUT_FILENO)`.  
This duplicates fd to the standard output file descriptor (STDOUT_FILENO, usually 1).  
This effectively overwrites the standard output, which initially points to the terminal, to now point to the open file `output.txt`.
3. Finally, the shell executes the ls command.  
The `ls` command writes its output to standard output, but because standard output has been redirected, the output is written to `output.txt` instead of the terminal.

# Question 8

Consider a file named "data.txt" initially containing the text "ABC".  
The following code snippet is executed:

```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>

int main() {
  int fd1, fd2;
  char buffer[4];

  fd1 = open("data.txt", O_RDWR);
  write(fd1, "DEF", 3);
  fd2 = dup(fd1);
  lseek(fd2, 0, SEEK_SET);
  write(fd2, "GHI", 3);
  close(fd1);
  close(fd2);

  return 0;
}
```

What are the final contents of "data.txt" after the execution of this code?

**Answer:**  
`GHI`

**Solution:**  
1. Initial State:  
The file "data.txt" contains "ABC".
2. `write(fd1, "DEF", 3);`:  
This writes "DEF" to the file, overwriting the original content.  
The file now contains "DEF".
3. `fd2 = dup(fd1);`:  
This duplicates `fd1`.  
Now both `fd1` and `fd2` point to the same open file table entry for "data.txt", which currently points to the beginning of the file (offset 0) and has the content "DEF".
4. `lseek(fd2, 0, SEEK_SET);`:  
This sets the file offset of `fd2` to the beginning of the file (offset 0).  
Note that this also affects `fd1` as they share the same open file table entry.
5. `write(fd2, "GHI", 3);`:  
This writes "GHI" to the file starting from offset 0, overwriting the first three bytes.  
The file now contains "GHI".
6. `close(fd1)`; and `close(fd2);`:  
These close the file descriptors.  
Since both descriptors refer to the same open file table entry, the file is closed when the reference count reaches zero.

# Question 9

Consider the following C code snippet:

```c
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>

int main() {
  int fd1, fd2;
  char buf[10];

  fd1 = open("file.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
  if (fd1 == -1) {
    perror("open");
    return 1;
  }

  fd2 = dup2(fd1, 1);
  if (fd2 == -1) {
    perror("dup2");
    return 1;
  }

  write(1, "hello", 5);

  close(fd1);
  //close(fd2); // This line is intentionally commented out.

  return 0;
}
```

After executing this code, what are the contents of `file.txt` and what happens if you uncomment the `close(fd2)` line?  
Explain your reasoning.

**Answer:**  
The file `file.txt` will contain "hello".  
If `close(fd2)` is uncommented, the file will be properly closed after writing, otherwise it will remain open until the process terminates.

**Solution:**  
1. Initial State:  
`fd1` points to the newly created `file.txt`, opened for writing.  
Standard output (file descriptor 1) typically points to the terminal.
2. `dup2(fd1, 1);`:  
This call duplicates `fd1` onto file descriptor 1.  
This redirects standard output to `file.txt`.  
The original standard output is closed.
3. `write(1, "hello", 5);`:  
This writes "hello" to file descriptor 1, which now refers to `file.txt`.
4. `close(fd1);`:  
This closes the file descriptor `fd1`.  
However, since `fd2` also points to the same open file table entry, the underlying file remains open.
5. `//close(fd2);` (Commented out):  
With this line commented out, the file "file.txt" remains open even after the program exits, because the open file table entry still has a reference count of 1 from `fd2`.
6. Uncommenting `close(fd2);`:  
If this line is uncommented, it closes `fd2`, which decrements the reference count in the open file table to 0.  
This closes the underlying file, ensuring that the contents ("hello") are properly written to disk and resources are released.

# Question 10

A programmer needs to open a file named "data.txt" for reading in a C program.  
Explain the key differences between using the standard I/O function `fopen("data.txt", "r")` and the Unix I/O system call `open("data.txt", O_RDONLY, 0)` in terms of buffering, error handling, and portability.  
Specifically, how does each approach handle buffering, how are errors reported, and which approach offers better portability across different operating systems?

**Answer:**  
`fopen()` offers buffered I/O and returns a FILE pointer upon success or NULL on error, while `open()` provides unbuffered I/O, returns a file descriptor, and sets errno on error.  
`fopen()` is more portable than `open()`.

**Solution:**  
Buffering:  
- `fopen()` uses buffered I/O.  
The standard I/O library maintains a buffer in user space.  
Data is transferred between the buffer and the kernel in larger chunks, improving efficiency.  
The `setbuf()` or `setvbuf()` functions can be used to control buffering behavior (fully buffered, line buffered, or unbuffered).
- `open()` uses unbuffered I/O by default.  
Each read or write system call directly interacts with the kernel.  
This can be less efficient for frequent small I/O operations.  
However, buffering can be implemented at the application level if needed.

Error Handling:
- `fopen()` returns a `FILE *` pointer.  
If the file cannot be opened, it returns `NULL`.  
The global variable `errno` is not set.  
Error checking relies on testing the return value against `NULL`.
- `open()` returns a file descriptor (a non-negative integer).  
If an error occurs, it returns -1, and the specific error code is stored in `errno`.  
`perror()` or `strerror()` can be used to obtain a human-readable error message.  

Portability:
- `fopen()` is part of the C standard library and is highly portable across different operating systems that support C.
- `open()` is a Unix system call and is less portable.  
It is typically available on Unix-like systems (Linux, macOS, BSD) but not directly on Windows.  
Windows provides analogous functions like `CreateFile()`.

# Question 11

Explain why using functions like `fgets`, `scanf`, `printf`, `strlen`, and `strcpy` can be problematic when handling binary files in C.  
Discuss platform-specific newline character interpretations and the implications of null bytes within binary data.

**Answer:**  
Text-oriented functions like `fgets`, `scanf`, and `printf` misinterpret newline characters in binary data.  
String functions like `strlen` and `strcpy` misinterpret null bytes within the binary data.

**Solution:**  
Functions like `fgets`, `scanf`, and `printf` are designed for text files and operate on lines delimited by newline characters.  
Binary files may contain bytes that match the newline character (0x0A on Linux/macOS, 0x0D 0x0A on Windows), causing these functions to misinterpret the data or terminate prematurely.  
String functions like `strlen` and `strcpy` rely on the null byte (0x00) to mark the end of a string.  
Binary files can contain null bytes as part of their data, leading to incorrect length calculations or truncated data when using these functions.  
Therefore, using these functions with binary files can lead to data corruption or misinterpretation.

