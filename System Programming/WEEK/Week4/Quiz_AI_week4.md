# 2025 Spring SNU System Programming - Weekly Quiz (Week 4)

We have prepared some light quizzes related to class content of week 4.  
These problems have been selected from those generated by **AI tool (Cramify)**,  
based on your class ppt content.

There is no need to submit anything after reviewing this material,  
but we hope it will help you review the class content you learned this week and prepare for the quiz.

---

Weekly Quiz has two documents, one with only the problems and  
the other with both the problems and solutions.  

# Question 1

| Data Type | Size (bytes) | Alignment (bytes) |
|-------|-------|-------|
| char	| 1 | 1 |
| short	| 2 | 2 |
| int	| 4 | 4 |
| long	| 8 | 8 |
| long double	| 16 | 16 |
| pointer	| 8 | 8 |

Consider a 64-bit x86-64 Linux system with the size and alignment requirements for various data types as shown in the table above.  
You are designing a struct named Data with the following members: `char c; long l; int i; char d;`.  
Calculate the total size of the struct Data considering data alignment.  
Then, explain how padding is used to achieve this alignment and why it's beneficial for performance.

# Question 2

Consider the following C code snippet:

```c
void modifyValue(int a, int *b) {
    a = 10;
    *b = 20;
}

int main() {
    int x = 5;
    int y = 5;
    modifyValue(x, &y);
    // What are the values of x and y after the function call?
}
```
Explain the final values of x and y after the call to modifyValue, highlighting the difference between how the two parameters are handled.

# Question 3

In C, if `p` is declared as `int *p;` and subsequently assigned the return value of `malloc(sizeof(int) * 5);`, which statement best describes the relationship between `p` and the allocated memory?

A) `p` becomes an array of 5 integers, directly storing the allocated values within itself.  
B) `p` holds the starting address of a dynamically allocated block of memory on the heap, sufficient to store 5 integers.  
C) `p` stores the size (in bytes) of the allocated memory block, and the actual data is stored elsewhere.  
D) `p` stores the first integer of the allocated array, and the subsequent integers are stored in contiguous memory locations after `p`.  

# Question 4

| Member | Description |
|-------|-------|
| `st_dev`	| Device ID |
| `st_ino`	| Inode number |
| `st_mode`	| File type and mode |
| `st_nlink`	| Number of hard links |
| `st_uid`	| User ID of owner |
| `st_gid`	| Group ID of owner |
| `st_rdev`	| Device ID (if special file) |
| `st_size`	| Total size, in bytes |
| `st_blksize`	| Block size for file system I/O |
| `st_blocks`	| Number of 512B blocks allocated |
| `st_atim`	| Time of last access |
| `st_mtim`	| Time of last modification |
| `st_ctim`	| Time of last status change |

Consider the struct stat structure used to retrieve file metadata.  
Using the table above, identify which member of the struct stat structure would store the following information:

1. The size of the file in bytes.
2. The last time the file's contents were modified.
3. The user ID of the file's owner.
4. The number of hard links to the file.
5. The file type and permissions.

# Question 5

Process A opens a file, "data.txt", twice using the `open()` system call.  
Explain how this scenario is represented within the kernel's file management structures, specifically referencing descriptor tables, the open file table, and the v-node table.  
How does this representation enable file sharing?

# Question 6

Process A opens "data.txt" twice using the `open()` system call, obtaining file descriptors 3 and 4.  
Process B then opens the same file, receiving file descriptor 5.  
Explain how the Unix kernel manages this scenario using the descriptor table, open file table, and v-node table.  
Specifically, describe the relationships between these structures and how they facilitate file sharing, including the role of reference counting.

# Question 7

Explain the system calls involved in redirecting standard output of a command, such as `ls`, to a file named `output.txt` in a Unix shell.  
Specifically, detail how the shell manipulates file descriptors to achieve this redirection.

# Question 8

Consider a file named "data.txt" initially containing the text "ABC".  
The following code snippet is executed:

```c
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>

int main() {
  int fd1, fd2;
  char buffer[4];

  fd1 = open("data.txt", O_RDWR);
  write(fd1, "DEF", 3);
  fd2 = dup(fd1);
  lseek(fd2, 0, SEEK_SET);
  write(fd2, "GHI", 3);
  close(fd1);
  close(fd2);

  return 0;
}
```

What are the final contents of "data.txt" after the execution of this code?

# Question 9

Consider the following C code snippet:

```c
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>

int main() {
  int fd1, fd2;
  char buf[10];

  fd1 = open("file.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
  if (fd1 == -1) {
    perror("open");
    return 1;
  }

  fd2 = dup2(fd1, 1);
  if (fd2 == -1) {
    perror("dup2");
    return 1;
  }

  write(1, "hello", 5);

  close(fd1);
  //close(fd2); // This line is intentionally commented out.

  return 0;
}
```

After executing this code, what are the contents of `file.txt` and what happens if you uncomment the `close(fd2)` line?  
Explain your reasoning.

# Question 10

A programmer needs to open a file named "data.txt" for reading in a C program.  
Explain the key differences between using the standard I/O function `fopen("data.txt", "r")` and the Unix I/O system call `open("data.txt", O_RDONLY, 0)` in terms of buffering, error handling, and portability.  
Specifically, how does each approach handle buffering, how are errors reported, and which approach offers better portability across different operating systems?

# Question 11

Explain why using functions like `fgets`, `scanf`, `printf`, `strlen`, and `strcpy` can be problematic when handling binary files in C.  
Discuss platform-specific newline character interpretations and the implications of null bytes within binary data.
