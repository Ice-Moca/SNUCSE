# 2025 Spring SNU System Programming - Weekly Quiz (Week 3)

We have prepared some light quizzes related to class content of week 3.  
These problems have been selected from those generated by **AI tool (Cramify)**,  
based on your class ppt content.

There is no need to submit anything after reviewing this material,  
but we hope it will help you review the class content you learned this week and prepare for the quiz.

---

Weekly Quiz has two documents, one with only the problems and  
the other with both the problems and solutions.  

# Question 1

Unix-like systems follow the "everything is a file" philosophy.  
Which of the following examples satisfy this philosophy?

A) A program writes data to a log file to record events.  
B) A programmer reads data from a file stored on a hard disk.  
C) A user creates a new text file to store a document.  
D) A system administrator configures network settings by modifying a file representing a network interface.  

# Question 2

Given the commands and outputs related to file linking in a Unix-like file system, analyze the following statements about hard links and soft links.  
Indicate True or False for each statement.

- a) A hard link creates a new file with identical content to the original file, effectively resulting in two separate files with the same data.

- b) Deleting a file that has multiple hard links removes the file's content from the storage device only when all hard links pointing to that file are deleted.

- c) Modifying a file through one hard link is reflected in all other hard links pointing to the same file, as they all share the same underlying data.

- d) A soft link, also known as a symbolic link, stores a copy of the target file's data, ensuring that even if the original file is deleted, the soft link still retains the data.

- e) Soft links can point to files across different file systems or even different storage devices, while hard links are restricted to the same file system as the original file.

# Question 3

A file named "report.pdf" has the permissions set as `-rwxr-x---`. The owner is "john", and the group is "finance".  
Which of the following actions can "lisa", a member of the "marketing" group, perform on this file?

A) Lisa can read and execute the file.  
B) Lisa cannot perform any actions on the file.  
C) Lisa can read the file but not execute it.  
D) Lisa can execute the file but not read it.

# Question 4

Given the following statements concerning file system security in a Unix-like environment, indicate True or False for each statement.

- a) A world-writable directory with execute permission allows any user on the system to execute files placed within that directory, posing a significant security risk if exploited by malicious actors.

- b) The sticky bit, when set on a directory, restricts file deletion within that directory to only the file owner and the directory owner, regardless of other users' permissions.

- c) The SUID (Set User ID) bit permits a program to execute with the file owner's permissions, while the SGID (Set Group ID) bit allows execution with the group's permissions, potentially enabling access to resources beyond the executing user's normal privileges.

- d) Setting the sticky bit on a file prevents its execution even if the execute permission is granted for the owner, group, or others.

- e) If a file system has the NOSUID option enabled, the SUID and SGID bits on files within that file system are ignored, mitigating the security risks associated with privilege escalation.

# Question 5

In a Unix-like operating system, a process is attempting to write data to a file.  
Describe the role of file descriptors in this process, explaining how they are obtained, what they represent, and how they are used by system calls like write() to interact with the file.  
Furthermore, explain what happens if the process attempts to write to a file descriptor that has already been closed.

# Question 6

A program opens a file named "data.txt" for writing, appending data to it if it exists.  
If an error occurs during the open operation, the program should exit.  
Which code snippet correctly implements this behavior?

A)
```c
int fd = open("data.txt", O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR);
if (fd < 0) {
  perror("open");
  exit(EXIT_FAILURE);
}  
```
B)
```c
FILE *fp = fopen("data.txt", "w");
if (fp == NULL) {
  perror("fopen");
  exit(EXIT_FAILURE);
}
```
C)
```c
int fd = open("data.txt", O_RDONLY | O_CREAT, S_IRUSR | S_IWUSR);
if (fd < 0) {
  perror("open");
  exit(EXIT_FAILURE);
}
```
D)
```c
int fd = creat("data.txt", O_WRONLY | O_APPEND);
if (fd < 0) {
  perror("creat");
  exit(EXIT_FAILURE);
}
```

# Question 7

| Feature | Unix I/O | Standard I/O |
|-------|-------|-------|
| Buffering	| No | Yes (fully buffered, line buffered, unbuffered) |
| Efficiency | High (direct system calls) |	Higher for character/line operations due to buffering|
| Complexity | More complex, requires handling short counts | Simpler interface, automatic short count handling |
| Async-signal safety	| Yes	| No |
| File Metadata Access | Yes | No |
| Suitability	| Signal handlers, network sockets, high-performance needs | Disk/terminal files, general programming tasks |

Consider the table above comparing Unix I/O and Standard I/O.  
A programmer is developing a real-time application that needs to log error messages to a file immediately, even during signal handling.  
Which I/O approach is more suitable for this scenario, and why?  
Explain the key factors influencing this choice, referencing specific features from the table.

# Question 8

Explain the differences between fully buffered, line buffered, and unbuffered I/O in Standard I/O.  
Describe a scenario where each type would be most appropriate and explain how each impacts the frequency of system calls.

# Question 9

A program needs to write a large volume of data to a file.  
Explain how using Standard I/O's `fwrite()` improves performance compared to directly using Unix I/O's `write()` system call, and describe the interaction between the two.

A) `fwrite()` uses a separate, faster system call than `write()` for file operations, leading to improved performance.  
B) Standard I/O and Unix I/O operate independently; `fwrite()`'s performance advantage comes from its optimized implementation in user space, not its interaction with `write()`.  
C) `fwrite()` bypasses the kernel and writes directly to the hard drive, making it faster than `write()`.  
D) Standard I/O's `fwrite()` buffers data, reducing the number of expensive `write()` system calls made by Unix I/O, thus improving performance for large file writes.
