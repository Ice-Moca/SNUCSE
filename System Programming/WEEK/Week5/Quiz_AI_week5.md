# 2025 Spring SNU System Programming - Weekly Quiz (Week 5)

We have prepared some light quizzes related to class content of week 5.  
These problems have been selected from those generated by **AI tool (Cramify)**,  
based on your class ppt content.

There is no need to submit anything after reviewing this material,  
but we hope it will help you review the class content you learned this week and prepare for the quiz.

---

Weekly Quiz has two documents, one with only the problems and  
the other with both the problems and solutions.  

# Question 1

Modern operating systems utilize virtual memory to address several key challenges related to memory management.  
Which of the following problems does virtual memory not directly solve?

A) Limited storage capacity on persistent storage devices.  
B) Managing the allocation of physical memory to multiple processes.  
C) Protecting processes from accessing each other's memory.  
D) Facilitating shared memory regions between processes.  

# Question 2

A process attempts to write to a memory page marked as read-only.  
Describe the most likely immediate system response and explain how this mechanism enhances system stability and security.

A) The write operation proceeds, but the data is silently discarded, preventing data corruption but potentially leading to application errors.  
B) The process is immediately terminated without any error message, preventing further damage but potentially losing unsaved data.  
C) The system prompts the user for permission to allow the write operation, enhancing security by requiring explicit authorization.  
D) A segmentation fault occurs, preventing memory corruption and protecting system stability and security by isolating processes.  

# Question 3

A program frequently accesses memory locations 0x1000, 0x1004, 0x1008, and 0x100C.  
Later, it accesses 0x2000, 0x2004, 0x2008, and 0x200C.  
Which of the following best describes the program's memory access pattern and its impact on cache effectiveness if the cache block size is 16 bytes?

A) The program demonstrates spatial locality, and a 16-byte cache block size effectively utilizes this pattern.  
B) The program's access pattern exhibits no locality, and cache block size is irrelevant.  
C) The program exhibits spatial locality, but a smaller cache block size would be more efficient.  
D) The program demonstrates temporal locality, and a larger cache block size would further improve performance.  

# Question 4

Regarding cache replacement policies, which of the following statements are true?  
Indicate True or False for each statement.

a) The Least Recently Used (LRU) policy always achieves the lowest possible miss rate for a given cache size.  

b) Approximations of LRU, such as clock algorithms, aim to reduce the complexity of tracking the exact order of accesses while maintaining reasonable performance.  

c) A capacity miss occurs when the cache is too small to hold the working set of data, regardless of the replacement policy used.  

d) In a fully associative cache, all replacement policies perform identically because any block can be placed anywhere in the cache.  

e) The choice of cache replacement policy has no impact on the number of cold misses.  

# Question 5

Consider a system with a fixed-size cache.  
If the program exhibits high spatial locality, increasing the cache block size is likely to reduce which type of cache miss, and why?  
Conversely, if the program exhibits low spatial locality, increasing the cache block size may increase which type of cache miss, and why?

A) High spatial locality: increases hit rate by improving data availability; Low spatial locality: decreases hit rate due to increased cache pollution from unused data.  
B) High spatial locality: reduces capacity misses by increasing effective cache size; Low spatial locality: increases compulsory misses due to fetching unnecessary data.  
C) High spatial locality: reduces conflict misses by distributing data across more sets; Low spatial locality: increases conflict misses due to more blocks mapping to the same set.  
D) High spatial locality: reduces compulsory misses by prefetching adjacent data; Low spatial locality: increases capacity misses due to reduced effective cache size.  

# Question 6

You are developing a program that processes large datasets where the exact size is unknown until runtime.  
Explain why using dynamic memory allocation with functions like `malloc()` is more advantageous than relying on statically allocated global variables in this scenario.  
Specifically, address the limitations of static allocation and how dynamic allocation overcomes them.

# Question 7

In C, when dynamically allocating memory using functions like `malloc()` and `realloc()`, where is this memory allocated, and how is this memory region managed?  
Explain the potential issues that can arise if this region is mismanaged.

# Question 8

A dynamic memory allocator allocates memory blocks in multiples of 8 bytes.  
A program requests 26 bytes of memory, and the allocator provides a 32-byte block. Later, the program frees this block.  
Another program then requests 12 bytes, and although 16 bytes (32 - 26 + 8 = 16 bytes) are technically available across the freed 32-byte block and other smaller free blocks scattered throughout the heap, no single free block is large enough to fulfill the 12-byte request.  
Identify the types of fragmentation present in this scenario.

A) Both internal and external fragmentation are present.  
B) Only internal fragmentation is present.  
C) Neither internal nor external fragmentation is present.  
D) Only external fragmentation is present.  

# Question 9

| Operation | Argument (bytes) | Return Value (Address)	|
|-------|-------|-------|
| malloc | 32 | 0x1000 |
| malloc | 16	| 0x1020 |
| malloc | 48 | 0x1030 |
| free | 0x1030 | - |
| free | 0x1020 | - |
| malloc | 24 | ? |

Consider a K&R-style dynamic memory allocator with a base size of 16 bytes.  
The table above shows a sequence of calls to malloc and free.  
What address will the fourth malloc call (requesting 24 bytes) return?  
Assume that the heap starts at address 0x1000 and that the allocator uses a first-fit strategy and coalesces adjacent free blocks.

# Question 10

In dynamic memory allocation, explain the benefits of employing a circular linked list to manage free blocks, particularly highlighting its impact on handling the 'end' of the list and potential performance optimizations related to the list's head.

# Question 11

A program requests 48 bytes of memory using `malloc()`.  
The memory allocator uses a base size of 16 bytes for allocation and maintains a linked list of free blocks.  
The allocator finds a free block of 112 bytes.  
Describe the steps the allocator takes to fulfill the request and manage the remaining free space.
