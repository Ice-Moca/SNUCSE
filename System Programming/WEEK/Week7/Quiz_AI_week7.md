# 2025 Spring SNU System Programming - Weekly Quiz (Week 7)

We have prepared some light quizzes related to class content of week 7.  
These problems have been selected from those generated by **AI tool (Cramify)**,  
based on your class ppt content.

There is no need to submit anything after reviewing this material,  
but we hope it will help you review the class content you learned this week and prepare for the quiz.

---

Weekly Quiz has two documents, one with only the problems and  
the other with both the problems and solutions.  

# Question 1

Categorize each of the following C code snippets as defining a global, external, or local linker symbol, and explain your reasoning:  

1. `int x = 5;`
2. `static int y = 10;`
3. `extern int z;`
4. `int my_function(int a) { return a * 2; }`
5. `static void helper_function(void) { /* ... */ }`

# Question 2

You are linking two object files, `a.o` and `b.o`.  
`a.o` defines a global variable `x` initialized to 5.  
`b.o` defines `x` with `#pragma weak x` and initializes it to 10.  
What will be the final value of x after linking, and which object file's definition will be used?  
Explain your reasoning based on the linker's symbol resolution rules.

# Question 3

| Symbol Type | Section | Visibility | Lifetime |
| ------- | ------- | ------- | ------- |
| Global initialized variable | .data | Global | Entire program execution |
| Global uninitialized variable | .bss | Global | Entire program execution |
| Local static initialized variable | .data | Local to the compilation unit | Entire program execution |
| Local static uninitialized variable | .bss | Local to the compilation unit | Entire program execution |
| Function | .text | Can be global or local | Entire program execution |

Consider the following C code snippet:
```c
int global_var = 10; 
static int static_var; 

void my_function() { 
  static int func_static_var = 5; 
  int local_var = 20; 
}
```
Using the table above, analyze and explain where each of the variables (global_var, static_var, func_static_var, local_var) and the function my_function would be placed within the corresponding sections of an ELF file.  
Further, describe the visibility and lifetime of each of these symbols.

# Question 4

| Relocation Entry | Symbol | Offset | Addend | Section Address | PC | Relocated Address |
| ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| R_X86_64_PC32 | var | 0x14 | -4 | 0x4000 | 0x4018 | ? |
| R_X86_64_64 | var | 0x8 | 0 | 0x6000 | N/A | ? |

Given the relocation information in the table above, calculate the relocated addresses for both the PC-relative (R_X86_64_PC32) and absolute (R_X86_64_64) references.  
Assume the symbol 'var' is located at address 0x5000. Show your calculations.

# Question 5

In the context of dynamic linking on x86-64 systems, explain the interplay between the PLT and GOT when a program calls an external function like printf.  
Specifically, describe the sequence of events and the role of each component in ensuring the correct execution of the external function.

# Question 6

In the context of linking and loading, explain the security implications of compiling a program with the "-fcommon" flag, particularly when linking with external libraries.  
Contrast this with the behavior when using "-fno-common".  Consider a scenario where both the main program and a third-party library declare a global variable with the same name.

# Question 7

You are building a program with two source files, `module1.c` and `module2.c`.  
`module1.c` contains the declaration `int global_var;` while `module2.c` contains the definition `int global_var = 5;`.  
When linking, you encounter the error "multiple definition of `'global_var'`".  
Explain the cause of this error in terms of symbol resolution and linker rules, and propose a solution to resolve it.

# Question 8

A software development team is working on a new operating system where minimizing the size of individual applications is paramount due to limited storage.  
Simultaneously, they want to ensure efficient use of system resources and easy maintenance of common system libraries.  
Considering these constraints, which library linking strategy would be MOST suitable and why?  

A) A combination of static and dynamic linking is ideal, using static linking for core functionalities and dynamic linking for less critical components to balance size and maintainability.  
B) Neither static nor dynamic linking is suitable; a custom, minimized library approach specific to the operating system's needs is required for optimal performance and size efficiency.  
C) Dynamic linking is most suitable due to its smaller application size and efficient resource use, crucial for limited storage environments.  
D) Static linking is most suitable as it avoids runtime dependencies, simplifying application deployment despite larger executable sizes.

# Question 9

Consider two scenarios:  
(1) A program uses standard C library functions for string manipulation.  
(2) A web server plugin loads specialized image processing functions only when a user uploads an image in a specific format.  
Which scenario employs load-time dynamic linking and which employs run-time dynamic linking, and why?  

A) Scenario 1 uses load-time linking for standard C library functions, while Scenario 2 uses run-time linking for specialized image processing functions loaded on demand.  
B) Both scenarios use run-time linking as it's the most efficient way to manage external libraries in modern operating systems.  
C) Scenario 1 uses run-time linking to optimize string manipulation, while Scenario 2 uses load-time linking for the image processing plugin to ensure it's always available.  
D) Both scenarios use load-time linking as all external functions are resolved before the program executes.

# Question 10

Position-independent code (PIC) is crucial for dynamic linking of shared libraries in modern operating systems.  
Why is PIC necessary for shared libraries to function correctly and what mechanisms are used to achieve position independence?  

A) PIC is primarily used for security purposes in shared libraries and prevents the libraries from being loaded at predictable memory locations, but it doesn't affect how code within the library accesses global data.  
B) PIC is necessary because shared libraries can be loaded at different memory addresses; it's achieved using PC-relative addressing and structures like the GOT and PLT.  
C) PIC is required for static linking of libraries and uses absolute addressing to ensure code executes correctly regardless of its location in memory.  
D) PIC is used to optimize code size in shared libraries and relies on hardcoded memory addresses to access global variables and functions.  

# Question 11

You are tasked with intercepting calls to the malloc function in a C program.  
Which interpositioning technique offers the most flexibility if you only have access to the compiled binary and do not possess the source code or the ability to relink the program?  

A) Static linking of a custom library  
B) Load/run-time interpositioning  
C) Link-time interpositioning  
D) Compile-time interpositioning  
