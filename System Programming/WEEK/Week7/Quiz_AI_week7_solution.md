# 2025 Spring SNU System Programming - Weekly Quiz (Week 7, with Solutions)

We have prepared some light quizzes related to class content of week 7.  
These problems have been selected from those generated by **AI tool (Cramify)**,  
based on your class ppt content.

There is no need to submit anything after reviewing this material,  
but we hope it will help you review the class content you learned this week and prepare for the quiz.

---

Weekly Quiz has two documents, one with only the problems and  
the other with both the problems and solutions.  

# Question 1

Categorize each of the following C code snippets as defining a global, external, or local linker symbol, and explain your reasoning:  

1. `int x = 5;`
2. `static int y = 10;`
3. `extern int z;`
4. `int my_function(int a) { return a * 2; }`
5. `static void helper_function(void) { /* ... */ }`

**Answer:**  
1. Global
2. Local
3. External
4. Global
5. Local

**Solution:**  
1. `int x = 5;`:  
This defines a global symbol. The variable x is declared without the static keyword, making it accessible from other modules.
2. `static int y = 10;`:  
This defines a local symbol. The static keyword restricts the visibility of y to the current module.
3. `extern int z;`:  
This declares an external symbol. It indicates that z is defined in another module and can be accessed from the current module.
4. `int my_function(int a) { return a * 2; }`:  
This defines a global symbol. Functions are global by default unless declared static.
5. `static void helper_function(void) { /* ... */ }`:  
This defines a local symbol. The static keyword limits the visibility of helper_function to the current module.

# Question 2

You are linking two object files, `a.o` and `b.o`.  
`a.o` defines a global variable `x` initialized to 5.  
`b.o` defines `x` with `#pragma weak x` and initializes it to 10.  
What will be the final value of x after linking, and which object file's definition will be used?  
Explain your reasoning based on the linker's symbol resolution rules.

**Answer:**  
5 (from `a.o`)

**Solution:**  
The linker's rules prioritize strong symbols over weak symbols.  
In this case, `a.o` defines `x` as a strong symbol (because it's a global initialized variable).  
`b.o` defines `x` as a weak symbol due to the `#pragma weak` directive.  
Therefore, the linker will choose the strong symbol from `a.o` and the final value of `x` will be 5.

# Question 3

| Symbol Type | Section | Visibility | Lifetime |
| ------- | ------- | ------- | ------- |
| Global initialized variable | .data | Global | Entire program execution |
| Global uninitialized variable | .bss | Global | Entire program execution |
| Local static initialized variable | .data | Local to the compilation unit | Entire program execution |
| Local static uninitialized variable | .bss | Local to the compilation unit | Entire program execution |
| Function | .text | Can be global or local | Entire program execution |

Consider the following C code snippet:
```c
int global_var = 10; 
static int static_var; 

void my_function() { 
  static int func_static_var = 5; 
  int local_var = 20; 
}
```
Using the table above, analyze and explain where each of the variables (global_var, static_var, func_static_var, local_var) and the function my_function would be placed within the corresponding sections of an ELF file.  
Further, describe the visibility and lifetime of each of these symbols.

**Answer:**  
`global_var`: .data, global visibility, program lifetime.  
`static_var`: .bss, local visibility, program lifetime.  
`func_static_var`: .data, local to function visibility, program lifetime.  
`local_var`: stack (not in ELF sections like the others), local visibility, function lifetime.  
`my_function`: .text, global/local visibility, program lifetime.

**Solution:**  
`global_var` is a global initialized variable, so it resides in the .data section.  
Its visibility is global, meaning it can be accessed from any part of the program, and its lifetime is the entire program execution.  
`static_var` is a local static uninitialized variable, thus it belongs to the .bss section.  
Its visibility is local to the compilation unit (the file it's defined in), and its lifetime is the entire program execution.  
`func_static_var` is a local static initialized variable within a function, so it's placed in the .data section.  
Its visibility is local to the function `my_function`, and its lifetime is the entire program execution - it persists across multiple calls to the function.  
`local_var` is a local variable declared within a function.  
It does not have a corresponding ELF section in the same way as the other variables because it resides on the stack, which is managed at runtime.  
Its visibility is local to the function `my_function`, and its lifetime is limited to a single execution of the function.  
`my_function` is a function, so its code is placed in the .text section.  
Its visibility can be global (if it's not declared static) allowing other files to call it, or local (if declared static) restricting its use to the current file.  
Its lifetime, like the other symbols in the ELF file, is the entire program execution.

# Question 4

| Relocation Entry | Symbol | Offset | Addend | Section Address | PC | Relocated Address |
| ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| R_X86_64_PC32 | var | 0x14 | -4 | 0x4000 | 0x4018 | ? |
| R_X86_64_64 | var | 0x8 | 0 | 0x6000 | N/A | ? |

Given the relocation information in the table above, calculate the relocated addresses for both the PC-relative (R_X86_64_PC32) and absolute (R_X86_64_64) references.  
Assume the symbol 'var' is located at address 0x5000. Show your calculations.

**Answer:**  
R_X86_64_PC32: 0x4F00  
R_X86_64_64: 0x5000

**Solution:**  
R_X86_64_PC32:  
The formula for PC-relative relocation is:  
Relocated Address = PC + encoded value, where encoded value = address of(r.symbol) + r.addend - (address of(section) + r.offset).
1. Calculate the encoded value:  
0x5000 + (−4) − (0x4000 + 0x14) = 0x5000 − 4 − 0x4014 = 0xEE8
2. Calculate the relocated address:  
0x4018 + 0xEE8 = 0x4F00  

R_X86_64_64:  
The formula for absolute relocation is:  
Relocated Address = address of(r.symbol) + r.addend.
1. Calculate the relocated address:  
0x5000 + 0 = 0x5000

# Question 5

In the context of dynamic linking on x86-64 systems, explain the interplay between the PLT and GOT when a program calls an external function like printf.  
Specifically, describe the sequence of events and the role of each component in ensuring the correct execution of the external function.

**Answer:**  
The PLT acts as an indirection layer, initially pointing to a resolver routine.  
Upon the first call to an external function, the resolver uses information stored in the GOT to determine the function's actual address and updates the GOT.  
Subsequent calls then use the updated GOT entry for direct access to the external function, optimizing performance.

**Solution:**  
1. Initial call:  
When the program first calls printf, the call instruction jumps to the corresponding entry in the PLT.
2. PLT entry:  
The PLT entry contains a jump instruction that initially targets the next instruction within the PLT.  
It also pushes a relocation offset onto the stack.
3. First call resolution:  
This next instruction jumps to a resolver routine.  
The resolver routine uses the relocation offset to determine the actual address of printf and updates the GOT entry for printf with this address.
4. Subsequent calls:  
On subsequent calls to printf, the PLT entry now jumps directly to the correct address stored in the GOT, bypassing the resolver routine.

# Question 6

In the context of linking and loading, explain the security implications of compiling a program with the "-fcommon" flag, particularly when linking with external libraries.  
Contrast this with the behavior when using "-fno-common".  Consider a scenario where both the main program and a third-party library declare a global variable with the same name.

**Answer:**  
Using "-fcommon" can lead to security risks due to the merging of global variables in the COMMON section.  
"-fno-common" prevents this merging by generating linker errors for multiple definitions, thus improving security.  
However, it doesn't prevent merging if the library already contains the global variable in the COMMON section.

**Solution:**  
With "-fcommon", uninitialized global variables are placed in the COMMON section.  
If an external library also declares a global variable with the same name, the linker merges them, potentially leading to unintended data sharing and security vulnerabilities, as demonstrated in the Coupang example where the password was leaked.  
With "-fno-common", the linker treats multiple definitions of the same global variable as an error, preventing accidental merging and enhancing security.  
However, if the library is pre-compiled and the global variable is already in the COMMON section within the library, "-fno-common" in the main program won't prevent the merging, as the linker still sees a single definition in the COMMON section.

# Question 7

You are building a program with two source files, `module1.c` and `module2.c`.  
`module1.c` contains the declaration `int global_var;` while `module2.c` contains the definition `int global_var = 5;`.  
When linking, you encounter the error "multiple definition of `'global_var'`".  
Explain the cause of this error in terms of symbol resolution and linker rules, and propose a solution to resolve it.

**Answer:**  
The error is caused by multiple definitions of `'global_var'`.  
Declare `global_var` as extern in `module1.c` and define it in only one file.

**Solution:**  
The linker error "multiple definition of `'global_var'`" arises because both `module1.c` and `module2.c` provide a definition for the symbol `global_var`.  
In `module1.c`, the declaration `int global_var;` implicitly creates a tentative definition, which is treated as a weak symbol.  
`module2.c` contains a strong definition `int global_var = 5;`.  
According to linker rule 1, multiple strong symbols are not allowed.  
Even though the declaration in `module1.c` creates a weak symbol, the linker promotes it to a strong symbol during the linking process if no other strong symbol is found.  
Since a strong symbol already exists in `module2.c`, the conflict occurs.  
To resolve this, ensure global_var is defined in only one source file (e.g., `module2.c`).  
In `module1.c`, declare it as `extern int global_var;` to indicate that it is defined elsewhere.

# Question 8

A software development team is working on a new operating system where minimizing the size of individual applications is paramount due to limited storage.  
Simultaneously, they want to ensure efficient use of system resources and easy maintenance of common system libraries.  
Considering these constraints, which library linking strategy would be MOST suitable and why?  

A) A combination of static and dynamic linking is ideal, using static linking for core functionalities and dynamic linking for less critical components to balance size and maintainability.  
B) Neither static nor dynamic linking is suitable; a custom, minimized library approach specific to the operating system's needs is required for optimal performance and size efficiency.  
C) Dynamic linking is most suitable due to its smaller application size and efficient resource use, crucial for limited storage environments.  
D) Static linking is most suitable as it avoids runtime dependencies, simplifying application deployment despite larger executable sizes.

**Answer: C**  

**Solution:**  
Static libraries, while straightforward to use, lead to larger executable sizes because the library code is copied into each application.  
This duplicates code across the system, wasting storage.  
Updating libraries also requires recompiling and relinking every application that uses them.  
Dynamic libraries address these issues.  
Only one copy of the shared library exists in memory, reducing overall system resource usage.  
Applications link to this shared library at runtime.  
Updates to the dynamic library don't require recompilation of dependent applications.  
Given the limited storage constraint, dynamic libraries are the preferred choice.

# Question 9

Consider two scenarios:  
(1) A program uses standard C library functions for string manipulation.  
(2) A web server plugin loads specialized image processing functions only when a user uploads an image in a specific format.  
Which scenario employs load-time dynamic linking and which employs run-time dynamic linking, and why?  

A) Scenario 1 uses load-time linking for standard C library functions, while Scenario 2 uses run-time linking for specialized image processing functions loaded on demand.  
B) Both scenarios use run-time linking as it's the most efficient way to manage external libraries in modern operating systems.  
C) Scenario 1 uses run-time linking to optimize string manipulation, while Scenario 2 uses load-time linking for the image processing plugin to ensure it's always available.  
D) Both scenarios use load-time linking as all external functions are resolved before the program executes.

**Answer: A**  

**Solution:**  
Scenario 1 uses load-time dynamic linking.  
Standard C library functions (like those for string manipulation) are typically linked when the program starts.  
This is handled by the dynamic linker (e.g., ld-linux.so) and ensures common functions are available without explicit loading.  
Scenario 2 uses run-time dynamic linking.  
The specialized image processing functions are loaded only when needed (when a specific image format is uploaded).  
This is done via functions like dlopen() and dlsym(), allowing the program to load functionality on demand, conserving resources and enabling modularity.

# Question 10

Position-independent code (PIC) is crucial for dynamic linking of shared libraries in modern operating systems.  
Why is PIC necessary for shared libraries to function correctly and what mechanisms are used to achieve position independence?  

A) PIC is primarily used for security purposes in shared libraries and prevents the libraries from being loaded at predictable memory locations, but it doesn't affect how code within the library accesses global data.  
B) PIC is necessary because shared libraries can be loaded at different memory addresses; it's achieved using PC-relative addressing and structures like the GOT and PLT.  
C) PIC is required for static linking of libraries and uses absolute addressing to ensure code executes correctly regardless of its location in memory.  
D) PIC is used to optimize code size in shared libraries and relies on hardcoded memory addresses to access global variables and functions.  

**Answer: B**  

**Solution:**  
Shared libraries need to be loadable at different memory addresses in different processes without requiring recompilation or relinking.  
PIC achieves this by using relative addressing modes, primarily PC-relative addressing, to access global variables and functions.  
Instead of absolute addresses, code and data within the shared library are accessed using offsets relative to the current program counter.  
The Global Offset Table (GOT) and the Procedure Linkage Table (PLT) are key data structures used to implement PIC.  
The GOT holds the absolute addresses of global variables and functions, and the PLT contains small code stubs that jump to the correct addresses in the GOT.  
The dynamic linker populates the GOT with the correct absolute addresses when the shared library is loaded, enabling the library's code to function correctly regardless of where it is loaded in memory.

# Question 11

You are tasked with intercepting calls to the malloc function in a C program.  
Which interpositioning technique offers the most flexibility if you only have access to the compiled binary and do not possess the source code or the ability to relink the program?  

A) Static linking of a custom library  
B) Load/run-time interpositioning  
C) Link-time interpositioning  
D) Compile-time interpositioning  

**Answer: B**  

**Solution:**  
Compile-time interpositioning requires modification of the source code, using macros to redirect calls.  
Link-time interpositioning requires access to the object files and uses linker flags like --wrap.  
Load/run-time interpositioning, using LD_PRELOAD, offers the most flexibility when you only have the binary.  
LD_PRELOAD loads a shared library before others, allowing your library's version of malloc to override the standard one.

