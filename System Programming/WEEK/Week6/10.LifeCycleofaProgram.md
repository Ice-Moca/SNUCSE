# **10. Life Cycle of a Program Lecture Summary**

## **1. Overview of the Compilation Process**

- A C program is transformed into an executable through multiple stages, involving:
  - **Preprocessing (`cpp`)** – macro expansion, file inclusion.
  - **Compilation (`cc1`)** – converts C to assembly.
  - **Assembly (`as`)** – converts assembly to object code.
  - **Linking (`ld` or `collect2`)** – produces the final executable.

## **2. GCC as a Compilation Driver**

- `gcc` manages all stages as a front-end driver.
- `gcc -v` shows internal tools and flags used in the transformation.
- Intermediate files include:
  - `.s` – assembly code
  - `.o` – object files
  - final binary – ELF executable

## **3. Separate Compilation Benefits (Why linking?)**
- **Linking?**
    - Linking is the process of collecting and combining various pieces of codes and data into a single file that can be loaded into memory and executed.
    - Performed at compile time
- **Modularity**: Instead of organizing a large application as one monolithic source file, one can decompose it into smaller, more manageable modules that can be modified and compiled separately.
- **Efficiency**:
  - Faster recompilation of modified files (Seperate compilation).
  - Reduced binary size through selective symbol inclusion from libraries.

## **4. Linker Responsibilities**

### **4.1 Symbol Resolution**
- Each source file may define or reference symbols (variables/functions).
- Linker resolves references by consulting symbol tables generated by the compiler.
- Example:
  ```c
  void swap(); // reference
  void swap() {} // definition
  ```

### **4.2 Relocation**
- Merging sections of the same type across object files (e.g., .data, .text).
- Update all references to the new positions of the relocated entries.

## **5. ELF (Executable and Linkable Format)**

### **5.1 Types of ELF Object Files**
- Relocatable (.o) – needs linking.
- Executable (a.out) – fully linked, ready to run.
- Shared Object (.so) – dynamically linkable at runtime or load-time.

### **5.2 ELF File Components**
- ELF Header – architecture, word size, entry point, file type.
- Section Header Table – metadata about code/data/debug sections.
- Segment Header Table – memory layout used by the OS loader.

### **5.3 Common Sections**
- .text – executable instructions
- .data – initialized global/static variables
- .bss – uninitialized variables (zero-initialized by loader)
- .rodata – read-only constants like string constants
- .symtab – symbol table (functions, variables, metadata)
- .rel.text, .rel.data – relocation info for code and data
- .debug, .line – optional debug information (enabled with -g)
- Section header table - offsets and sizes of each section

## **6. Using readelf for ELF Inspection**
- Useful readelf options:
    - -a: all informations
    - -s: symbol table
    - -S: section headers
    - -r: relocation info

## **7. Summary**
- Linking enables modularity and reuse across compile-time, load-time, and run-time.
- ELF provides a unified format for all stages:
- .o, .so, and executables share a common structure.
- Tools like readelf, nm, objdump facilitate deep inspection.
- Understanding this life cycle is critical for systems programming, optimization, and secure binary handling.