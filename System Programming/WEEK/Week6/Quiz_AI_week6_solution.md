# 2025 Spring SNU System Programming - Weekly Quiz (Week 6, with Solutions)

We have prepared some light quizzes related to class content of week 6.  
These problems have been selected from those generated by **AI tool (Cramify)**,  
based on your class ppt content.

There is no need to submit anything after reviewing this material,  
but we hope it will help you review the class content you learned this week and prepare for the quiz.

---

Weekly Quiz has two documents, one with only the problems and  
the other with both the problems and solutions.  

# Question 1

Arrange the following steps in the correct order to represent the life cycle of a C program from source code to a running process:

- Loader (execve)
- C compiler (cc1/cpp)
- Dynamic linker (ld-linux.so)
- Assembler (as)
- Linker (ld/collect2)

A) The correct order is C compiler, Assembler, Linker, Loader, and Dynamic linker.  
B) The correct order is Loader, C Compiler, Assembler, Linker, and Dynamic linker.  
C) The correct order is C compiler, Linker, Assembler, Loader, and Dynamic linker.  
D) The correct order is Assembler, C compiler, Linker, Loader, and Dynamic linker.

**Answer: A**

**Solution:**  
1. The C compiler (cc1/cpp) processes the source code (.c files), performing preprocessing, compilation, and assembly preparation.
2. The Assembler (as) converts the assembly code (.s files) generated by the compiler into relocatable object files (.o files).
3. The Linker (ld/collect2) combines the relocatable object files, including any necessary libraries, to create an executable file.
4. The Loader (execve), invoked by the operating system, loads the executable file into memory, setting up the necessary runtime environment.
5. For dynamically linked libraries, the Dynamic linker (ld-linux.so) resolves external library references during runtime, ensuring the program has access to all required functions.

# Question 2

A program consists of two files, main.c and helper.c.  
main.c calls a function calculate() defined in helper.c, and accesses a global variable data also defined in helper.c.  
During the linking process, what actions does the linker take to ensure the program executes correctly?

A) The linker copies the code of calculate() and data into main.c, eliminating the need for external references.  
B) The linker resolves references to calculate() and data by finding their definitions, and then relocates them by assigning load addresses and updating references.  
C) The linker dynamically loads helper.c at runtime, resolving the symbols only when they are needed by main.c.  
D) The linker creates a mapping between the names calculate() and data and their corresponding memory addresses in helper.c, but does not modify the code.

**Answer: B**

**Solution:**  
The linker performs two key operations:
1. Symbol resolution:  
The linker resolves the references to calculate() and data in main.c by finding their definitions in helper.c.  
This ensures that the correct function and variable are used.
2. Relocation: The linker combines the object code of main.c and helper.c.  
It then assigns load addresses to each code section and data variable, including calculate() and data.  
Finally, it modifies the references to calculate() and data in the main.c code to reflect their final assigned addresses.

# Question 3

Regarding the Executable and Linkable Format (ELF), which of the following statements are true?  
Indicate True or False for each statement.

a) ELF is a standard binary format used for object files, executables, and shared libraries, promoting code modularity and efficient memory usage.  

**Answer: True**  

**Solution:**  
ELF's unified format facilitates separate compilation and dynamic linking, enabling modularity and efficient memory management by sharing common code.

b) The ELF header contains essential information such as word size, byte ordering, file type, and machine type, enabling the system to correctly interpret and execute the binary.  

**Answer: True**  

**Solution:**  
The ELF header provides critical metadata for system loaders and dynamic linkers, ensuring proper program loading and execution.  

c) The .bss section in an ELF file contains initialized global and static variables, contributing to the initial memory image of the program.  

**Answer: False**  

**Solution:**  
The .bss section holds uninitialized global and static variables.  
Initialized data resides in the .data section.

d) Relocation information within ELF files, such as found in .rel.text and .rel.data, guides the linker in adjusting addresses of code and data during the linking process.  

**Answer: True**  

**Solution:**  
Relocation entries specify how to modify code and data references to reflect their final addresses after linking, crucial for correct program execution.

e) The symbol table (.symtab) in an ELF file stores information about global variables and functions, but not local variables, simplifying the linking process.  

**Answer: True**  

**Solution:**  
While the symbol table primarily contains global symbols, it can also include information about local static variables, depending on compiler options and debugging information.  

# Question 4

Regarding the three types of object files in a system, which of the following statements are true?  
Indicate True or False for each statement.

a) Relocatable object files (.o files) contain code and data that can be combined with other relocatable object files to create an executable object file.  

**Answer: True**  

**Solution:**  
This is the primary purpose of relocatable object files. They are the building blocks for creating executable programs.  

b) Executable object files (e.g., a.out files) are ready to be directly loaded into memory and executed without further linking.  

**Answer: True**  

**Solution:**  
Executable files have all necessary symbols resolved and relocated, making them ready for execution.  

c) Shared object files (.so files) are a type of relocatable object file that can be dynamically linked at either load time or runtime.  

**Answer: True**  

**Solution:**  
Shared object files allow for code sharing and dynamic linking, improving efficiency and modularity.  

d) Relocatable object files can be directly executed by the operating system.  

**Answer: False**  

**Solution:**  
Relocatable object files need to be linked to resolve external references before they can be executed.  

e) Shared object files are statically linked at compile time, resulting in a larger executable size.  

**Answer: False**  

**Solution:**  
Shared object files are dynamically linked, either at load time or runtime, and do not increase the size of the initial executable.  

# Question 5

A large software project is divided into multiple source files, each responsible for a specific feature.  
Discuss how separate compilation enhances both the development process and the maintainability of this project, focusing on the aspects of modularity and efficiency.  
Specifically, address how changes to a single feature impact the overall build process.

**Answer:**  
Separate compilation enhances modularity by allowing independent development and maintenance of individual source files.  
This improves efficiency by requiring recompilation of only modified files, reducing build time and simplifying maintenance tasks.

**Solution:**  
Modularity:  
Separate compilation allows developers to work on individual source files (modules) independently.  
This promotes modular design, where each module encapsulates a specific functionality.  
Changes within one module are less likely to affect others, reducing the risk of introducing bugs and simplifying debugging.  

Efficiency (Development):  
When a single source file is modified, only that file needs to be recompiled.  
The other object files remain unchanged, and the linker simply combines them with the newly compiled object file to create the executable.  
This significantly reduces compilation time compared to recompiling the entire project.

Efficiency (Maintenance):  
Modularity through separate compilation simplifies maintenance.  
When a bug fix or feature update is required, developers can isolate the relevant module, make the necessary changes, recompile only that module, and then relink.  
This targeted approach minimizes the scope of testing and reduces the likelihood of unintended consequences in other parts of the software.

# Question 6

The K&R malloc implementation uses a first-fit strategy with a circular linked list of free blocks.  
Discuss the advantages and disadvantages of this approach, specifically addressing its impact on memory utilization (fragmentation), execution time for malloc and free operations, and the overall complexity of implementation.

**Answer:**  
Advantages:  
Simplicity of implementation, reasonable space efficiency due to block splitting, and potential locality improvements with next-fit.  
Disadvantages:  
External fragmentation due to first-fit, linear time complexity for malloc and free, and lack of control over block placement.  

**Solution:**  
Advantages:  
- Simplicity:  
The K&R approach is relatively simple to implement.  
The code for traversing a circular linked list and basic allocation/deallocation is straightforward.
- Reasonable space efficiency:  
Splitting large blocks during allocation helps avoid internal fragmentation where allocated blocks hold more space than requested.
- Improved locality (next-fit optimization):  
The next-fit variation, where the search for free blocks begins from the previously allocated block, can improve locality and reduce search times in some cases.  

Disadvantages:
- External Fragmentation:  
First-fit can lead to external fragmentation, where there's enough total free memory, but it's scattered in small non-contiguous blocks, making it impossible to satisfy larger requests.
- Linear Time Complexity:  
Both malloc and free operations require traversing the free list, leading to linear time complexity.  
This can become a performance bottleneck, especially with a large number of free blocks.
- No control over block placement:  
First-fit doesn't consider factors like minimizing fragmentation or optimizing for spatial locality, potentially leading to suboptimal memory usage patterns.

# Question 7

In dynamic memory allocation, how does a binning approach with segregated free lists improve performance compared to a single explicit free list, especially when allocating blocks of varying sizes?  
Consider both the time complexity for allocation and the potential for memory fragmentation.

**Answer:**  
Binning improves allocation speed by reducing search time from linear to logarithmic (or better) and reduces fragmentation by grouping similarly sized blocks.

**Solution:**  
Binning improves dynamic memory allocation by categorizing free blocks by size into separate lists (bins).  
When a request for memory comes in, the allocator checks the appropriate bin for a fitting block, reducing search time from `O(n)` for a single free list to `O(log(n))` or better if power-of-two size classes are used.  
This targeted search also minimizes fragmentation by allocating similarly sized blocks together, unlike a single free list where small blocks can get scattered throughout the heap, making it harder to find contiguous space for larger allocations.

# Question 8

In a dynamic memory allocator using an explicit free list, explain how the introduction of headers and footers in each memory block improves the efficiency of the `free()` operation, specifically regarding coalescing with adjacent free blocks.  
Consider a scenario where a block `B` is being freed, and both its preceding and succeeding blocks in memory are already free.  

**Answer:**  
Headers and footers allow `free()` to directly access adjacent block information (size and allocated status) using pointer arithmetic.  
This enables constant-time coalescing with neighboring free blocks by simply updating the size field in the header and footer of the combined block and adjusting free list pointers, significantly improving efficiency compared to traversing a singly-linked free list without footers.  

**Solution:**  
Headers and footers enable efficient coalescing during `free()` by providing direct access to adjacent block information.
1. Accessing Adjacent Block Information:  
When freeing block `B`, the footer of the preceding block and the header of the succeeding block can be directly accessed using pointer arithmetic from `B`'s header.  
The footer of `B` also contains the size, allowing for easy traversal.
2. Determining Free Status:  
The header of each block contains an allocated/free flag. By checking the flags in the adjacent blocks' headers, the `free()` function can immediately determine if coalescing is possible.
3. Efficient Coalescing:  
If an adjacent block is free, the size in its header (and footer) is updated to include the size of `B`.  
The pointers in the free list are then adjusted to remove the adjacent free block and insert the newly coalesced larger block.  
This avoids the need to traverse the entire free list to find the correct insertion point, as in a singly-linked list without footers.  

In the scenario where both preceding and succeeding blocks are free, the process is similar.  
`B` is coalesced with both neighbors by updating the size and pointers of the first free block to encompass all three blocks.  
The other two blocks are removed from the free list.

# Question 9

In a dynamic memory allocation system, a program has just freed a block of memory at address 0x00001000 with a size of 16 bytes.  
Adjacent to this freed block, at address 0x00001010, there is another free block of 24 bytes.  
If coalescing is enabled, what will be the starting address and size of the resulting free block after the 16-byte block is freed?

A) Starting address: 0x00001000, Size: 40 bytes  
B) Starting address: 0x00001000, Size: 16 bytes  
C) Starting address: 0x00001010, Size: 24 bytes  
D) Starting address: 0x00001010, Size: 40 bytes

**Answer: A**  

**Solution:**  
When a 16-byte block at 0x00001000 is freed and coalescing is enabled, the memory manager checks for adjacent free blocks.  
It finds a 24-byte free block at 0x00001010 (immediately following the 16-byte block). The two blocks are combined into a single contiguous free block.  
The starting address remains 0x00001000, and the new size is the sum of the two blocks: 16 bytes + 24 bytes = 40 bytes.

# Question 10

A long-running server application experiences performance degradation due to memory fragmentation.  
The current dynamic memory allocation strategy employs a first-fit approach with a single free list.  
Discuss two alternative memory allocation strategies that could mitigate this fragmentation issue and explain the advantages and disadvantages of each in this scenario.  
Consider factors such as allocation speed, memory utilization, and implementation complexity.

**Answer:**  
Two strategies to mitigate memory fragmentation are segregated free lists (binning) and best-fit allocation.  
Binning improves allocation speed and memory utilization but increases implementation complexity and can lead to internal fragmentation.  
Best-fit minimizes external fragmentation but has slower allocation speed and increased implementation complexity.

**Solution:**  
1. Segregated Free Lists (Binning):  
- Concept:  
Maintain multiple free lists, each dedicated to a specific size class of memory blocks.  
When a request arrives, the allocator searches the appropriate free list for a block of the required size or slightly larger.
- Advantages:  
  - Improved allocation speed:  
  Searching within a size class is faster than traversing a single, large free list.
  - Better memory utilization:  
  Reduces external fragmentation by allocating blocks of similar sizes together.
- Disadvantages:
  - Increased implementation complexity:  
  Requires managing multiple free lists and handling block splitting/coalescing across size classes.
  - Potential internal fragmentation:  
  If size classes are too broad, allocated blocks might be significantly larger than requested, wasting memory.
2. Best-Fit Allocation:
- Concept:  
Search the entire free list and allocate the smallest free block that satisfies the request size.
- Advantages:
  - Minimizes external fragmentation:  
  By allocating the smallest suitable block, it leaves larger contiguous free blocks available for future allocations.
- Disadvantages:
  - Slower allocation speed:  
  Requires searching the entire free list for every allocation request, which can be time-consuming, especially with a large number of free blocks.
  - Increased implementation complexity:  
  Requires maintaining a sorted free list or using a more complex data structure to efficiently find the best-fit block.

